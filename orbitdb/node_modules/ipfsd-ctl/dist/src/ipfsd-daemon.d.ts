export = Daemon;
/**
 * @typedef {import("./types").ControllerOptions} ControllerOptions
 * @typedef {import("./types").Controller} Controller
 */
/**
 * Controller for daemon nodes
 *
 * @class
 *
 */
declare class Daemon {
    /**
     * @class
     * @param {Required<ControllerOptions>} opts
     */
    constructor(opts: Required<ControllerOptions>);
    opts: Required<import("./types").ControllerOptions>;
    path: any;
    exec: string;
    env: any;
    disposable: boolean;
    subprocess: execa.ExecaChildProcess<string> | null;
    initialized: boolean;
    started: boolean;
    clean: boolean;
    /** @type {Multiaddr} */
    apiAddr: Multiaddr;
    grpcAddr: Multiaddr | null;
    gatewayAddr: Multiaddr | null;
    api: any;
    /**
     * @private
     * @param {string} addr
     */
    private _setApi;
    /**
     * @private
     * @param {string} addr
     */
    private _setGrpc;
    /**
     * @private
     * @param {string} addr
     */
    private _setGateway;
    _createApi(): void;
    /**
     * Initialize a repo.
     *
     * @param {import('./types').InitOptions} [initOptions={}]
     * @returns {Promise<Controller>}
     */
    init(initOptions?: import("./types").InitOptions | undefined): Promise<Controller>;
    /**
     * Delete the repo that was being used. If the node was marked as disposable this will be called automatically when the process is exited.
     *
     * @returns {Promise<Daemon>}
     */
    cleanup(): Promise<Daemon>;
    /**
     * Start the daemon.
     *
     * @returns {Promise<Daemon>}
     */
    start(): Promise<Daemon>;
    /**
     * Stop the daemon.
     *
     * @param {object} [options]
     * @param {number} [options.timeout=60000] - How long to wait for the daemon to stop
     * @returns {Promise<Daemon>}
     */
    stop(options?: {
        timeout?: number | undefined;
    } | undefined): Promise<Daemon>;
    /**
     * Get the pid of the `ipfs daemon` process.
     *
     * @returns {Promise<number>}
     */
    pid(): Promise<number>;
    /**
     * Call `ipfs config`
     *
     * If no `key` is passed, the whole config is returned as an object.
     *
     * @private
     * @param {string} [key] - A specific config to retrieve.
     * @returns {Promise<Object | string>}
     */
    private _getConfig;
    /**
     * Replace the current config with the provided one
     *
     * @private
     * @param {object} config
     * @returns {Promise<Daemon>}
     */
    private _replaceConfig;
    /**
     * Get the version of ipfs
     *
     * @returns {Promise<string>}
     */
    version(): Promise<string>;
}
declare namespace Daemon {
    export { ControllerOptions, Controller };
}
import execa = require("execa");
import { Multiaddr } from "multiaddr";
type Controller = import("./types").Controller;
type ControllerOptions = import("./types").ControllerOptions;
//# sourceMappingURL=ipfsd-daemon.d.ts.map